---
title: "flexdashboard: IMPT meta analysis"
runtime: shiny
output: 
  flexdashboard::flex_dashboard:
    social: menu
    source_code: embed 
    vertical_layout: scroll
---


```{r load packages, include=FALSE}
# Package names

library(dplyr)
library(DiagrammeR)
library(DT)
library(flexdashboard)
library(forestplot)
library(formattable)
library(data.table)
library(gsheet)
library(htmltools)
library(Hmisc)
library(lessR)
library(magrittr)
library(meta)
library(metafor)
library(plotly)
library(png)
library(PRISMAstatement)
library(psych)
library(reactable)
library(readxl)
library(rsconnect)
library(shiny)
library(stringr)
library(summarytools)
library(tidyr)
library(tidyverse)
library(wesanderson)
library(revtools)
```

```{r load data, include=FALSE}
source("load_data.R", local = knitr::knit_global())
```

```{r prepare descriptive tables, include=FALSE}
source("descriptive_tables_md.R", local = knitr::knit_global())
```

```{r questionnaires dataframe, echo=FALSE}
source("questionnaires_dataframe.R", local = knitr::knit_global())
```

```{r}
source("shiny_fp_prep_md.R", local = knitr::knit_global())
```

```{r}
source("prep_ft_assessment_table.R", local = knitr::knit_global())
```

Home {data-orientation=columns}
=======================================================================

Column {.sidebar data-width=500}
-------------------------------------
### Interdisciplinary multimodal pain treament programs: a living repository

This online repository contains all study data of a systematic review and meta analysis on the development over time of interdisciplinary multimodal pain treatment (IMPT) programs. [click here](https://www.crd.york.ac.uk/prospero/display_record.php?RecordID=76093) for the study protocol. <br />

The study procedures are depicted in the figure on the right side. The main advantage of this infrastructure is that data extraction forms that have been double checked are automatically added to the analyses within this dashboard. This facilitates regular updates. 

The manuscript of the base review is currently in preparation for submission. More details regarding publication will be presented on this page <br />

The R scripts and dataset will be made available via Github along with the publication of the manuscript of the base review. <br />

[click here](forms/second_round_screening_form.pdf) for the second round screening forms. <br />
[click here]() for the data extraction forms. <br />
[click here]() for the risk of bias assessment forms. <br />

For questions or comments, please contact the corresponding author via stefan.elbers@hu.nl

Column
-------------------------------------

```{r}
img = readPNG("fp_pic.png")
```


Flow Chart {data-orientation=rows}
=======================================================================

Row {data-height=1200}
-------------------------------------
### flow chart
```{r}
prisma(31894, 90, 17955, 17955, 17588, 374, 311, 63, 56)
```

Study/patient characteristics {data-orientation=rows}
=======================================================================

Row {data-height=1000}
-------------------------------------
### Study and patient characteristics

```{r}
#create table 1 with reactable
reactable(t1,
          columns = list(
            "author (year)" = colDef(minWidth = 105),
            cohort_id = colDef(maxWidth = 30, name = "ID"),
            "cohort name" = colDef(minWidth = 105),
            "study sample size" = colDef(format = colFormat(digits = 0))
          ),
          defaultColGroup = colGroup(headerClass = "header"),
          style = list(fontFamily = "Arial Narrow", fontSize = "14px"),
          columnGroups = list(
            colGroup(name = "sample size", columns = sample_cols),
            colGroup(name = "patient characteristics", columns = patient_cols)
          ),
          defaultColDef = colDef(
            header = function(value) gsub("_", " ", value, fixed = TRUE),
            cell = function(value) format(value),
            align = "left",
            minWidth = 70
            ),
          searchable = TRUE,
          showPageSizeOptions = TRUE
          )
          
```

Intervention characteristics {data-orientation=rows}
=======================================================================

Row {data-height=1000}
-------------------------------------
### table intervention characteristics

```{r}
#create table 2 with reactable
reactable(t2,
          defaultSorted = "author_year",
          defaultSortOrder = "asc",
          defaultColGroup = colGroup(headerClass = "header"),
          style = list(fontFamily = "Arial Narrow", fontSize = "14px"),
          columnGroups = list(
            colGroup(name = "Treatment modalities", columns = procedure_cols),
            colGroup(name = "Healthcare providers", columns = hcp_cols)
            ),
          defaultColDef = colDef(
            header = function(value) gsub("_", " ", value, fixed = TRUE),
            cell = function(value) format(value, nsmall = 1),
            align = "left",
            minWidth = 70,
            headerStyle = list(background = "#f7f7f8")
            ),
          columns = list(
            author_year = colDef(minWidth = 105),
            other_procedures = colDef(minWidth = 200),
            other_healthcare_providers = colDef(minWidth = 110),
            followup_sessions_description = colDef(minWidth = 150),
            cohort_id = colDef(maxWidth = 30, name = "ID"),
            ed = colDef(maxWidth = 30, cell = function(value) {
              # Render as ✘ or ✓
              if (value == 0) "\u2718" else "\u2713"
              }, style = function(value){
                if (value == 0) {color <- '#ABB2B9'} else {color <- '#28B463'}
                list(background = color)
              }),
            ex = colDef(maxWidth = 30, cell = function(value) {
              # Render as ✘ or ✓
              if (value == 0) "\u2718" else "\u2713"
            }, style = function(value){
              if (value == 0) {color <- '#ABB2B9'} else {color <- '#28B463'}
              list(background = color)
              }),
            ga = colDef(maxWidth = 30, cell = function(value) {
              # Render as ✘ or ✓
              if (value == 0) "\u2718" else "\u2713"
            }, style = function(value){
              if (value == 0) {color <- '#ABB2B9'} else {color <- '#28B463'}
              list(background = color)
            }),
            ph = colDef(maxWidth = 30, cell = function(value) {
              # Render as ✘ or ✓
              if (value == 0) "\u2718" else "\u2713"
            }, style = function(value){
              if (value == 0) {color <- '#ABB2B9'} else {color <- '#28B463'}
              list(background = color)
            }),
            wo = colDef(maxWidth = 30, cell = function(value) {
              # Render as ✘ or ✓
              if (value == 0) "\u2718" else "\u2713"
            }, style = function(value){
              if (value == 0) {color <- '#ABB2B9'} else {color <- '#28B463'}
              list(background = color)
            }),
            bt = colDef(maxWidth = 30, cell = function(value) {
              # Render as ✘ or ✓
              if (value == 0) "\u2718" else "\u2713"
            }, style = function(value){
              if (value == 0) {color <- '#ABB2B9'} else {color <- '#28B463'}
              list(background = color)
            }),
            pm = colDef(maxWidth = 30, cell = function(value) {
              # Render as ✘ or ✓
              if (value == 0) "\u2718" else "\u2713"
            }, style = function(value){
              if (value == 0) {color <- '#ABB2B9'} else {color <- '#28B463'}
              list(background = color)
            }),
            ba = colDef(maxWidth = 30, cell = function(value) {
              # Render as ✘ or ✓
              if (value == 0) "\u2718" else "\u2713"
            }, style = function(value){
              if (value == 0) {color <- '#ABB2B9'} else {color <- '#28B463'}
              list(background = color)
            }),
            te = colDef(maxWidth = 30, cell = function(value) {
              # Render as ✘ or ✓
              if (value == 0) "\u2718" else "\u2713"
            }, style = function(value){
              if (value == 0) {color <- '#ABB2B9'} else {color <- '#28B463'}
              list(background = color)
            }),
            re = colDef(maxWidth = 30, cell = function(value) {
              # Render as ✘ or ✓
              if (value == 0) "\u2718" else "\u2713"
            }, style = function(value){
              if (value == 0) {color <- '#ABB2B9'} else {color <- '#28B463'}
              list(background = color)
            }),
            phy = colDef(maxWidth = 30, cell = function(value) {
              # Render as ✘ or ✓
              if (value == 0) "\u2718" else "\u2713"
            }, style = function(value){
              if (value == 0) {color <- '#ABB2B9'} else {color <- '#28B463'}
              list(background = color)
            }),
            psy = colDef(maxWidth = 30, cell = function(value) {
              # Render as ✘ or ✓
              if (value == 0) "\u2718" else "\u2713"
            }, style = function(value){
              if (value == 0) {color <- '#ABB2B9'} else {color <- '#28B463'}
              list(background = color)
            }),
            pt = colDef(maxWidth = 30, cell = function(value) {
              # Render as ✘ or ✓
              if (value == 0) "\u2718" else "\u2713"
            }, style = function(value){
              if (value == 0) {color <- '#ABB2B9'} else {color <- '#28B463'}
              list(background = color)
            }),
            ot = colDef(maxWidth = 30, cell = function(value) {
              # Render as ✘ or ✓
              if (value == 0) "\u2718" else "\u2713"
            }, style = function(value){
              if (value == 0) {color <- '#ABB2B9'} else {color <- '#28B463'}
              list(background = color)
            }),
            nur = colDef(maxWidth = 30, cell = function(value) {
              # Render as ✘ or ✓
              if (value == 0) "\u2718" else "\u2713"
            }, style = function(value){
              if (value == 0) {color <- '#ABB2B9'} else {color <- '#28B463'}
              list(background = color)
            }),
            swo = colDef(maxWidth = 30, cell = function(value) {
              # Render as ✘ or ✓
              if (value == 0) "\u2718" else "\u2713"
            }, style = function(value){
              if (value == 0) {color <- '#ABB2B9'} else {color <- '#28B463'}
              list(background = color)
            })
          ),
          bordered = FALSE,
          highlight = FALSE,
          striped = FALSE,
          searchable = TRUE,
          showPageSizeOptions = TRUE,
          onClick = "expand"
          )
```

Time Series {data-orientation=rows}
=======================================================================

Row {data-height=600 .tabset .tabset-fade}
-------------------------------------

### Pain interference

```{r timeseries pain interference}
#subset dataset with measurements on pain_interference

dat_pinter <- dat_clean %>%
    dplyr::filter(measurements_pain_interference == "yes")

#create dataframe for mean values over time  
ts_m <- select (dat_pinter, cohort, author, year, cohort_id, pinter_pre_m, pinter_post_m, pinter_fu1_m,
                  pinter_fu2_m, pinter_fu3_m, measurements_pain_interference, pinter_name_measurement_instrument) %>%
  rename(instrument_name = pinter_name_measurement_instrument, 
         pre_m = pinter_pre_m,
         post_m = pinter_post_m,
         fu1_m = pinter_fu1_m,
         fu2_m = pinter_fu2_m,
         fu3_m = pinter_fu3_m,
         instrument_present = measurements_pain_interference)

#create dataframe for SD values over time and change columns to numeric  
ts_sd <- select (dat_pinter, cohort, pinter_pre_sd, pinter_post_sd, pinter_fu1_sd,
                 pinter_fu2_sd, pinter_fu3_sd) %>%
  rename( pre_sd = pinter_pre_sd,
          post_sd = pinter_post_sd,
          fu1_sd = pinter_fu1_sd,
          fu2_sd = pinter_fu2_sd,
          fu3_sd = pinter_fu3_sd)

cols.num <- c("pre_sd","post_sd", "fu1_sd", "fu2_sd", "fu3_sd")
ts_sd[cols.num] <- sapply(ts_sd[cols.num],as.numeric)

#create dataframe for time and add pre/post values  
ts_t <- select (dat_pinter, cohort, pinter_fu1_t, pinter_fu2_t, pinter_fu3_t) %>%
  rename( fu1_t = pinter_fu1_t,
          fu2_t = pinter_fu2_t,
          fu3_t = pinter_fu3_t)

ts_t$pre_t = -5
ts_t$post_t = 0

#convert to long dataset
# The arguments to gather():
# - data: Data object
# - key: Name of new key column (made from names of data columns)
# - value: Name of new value column
# - ...: Names of source columns that contain values
# - factor_key: Treat the new key column as a factor (instead of character vector)
ts_m_long <- pivot_longer(ts_m, 
                          cols = c("pre_m", "post_m", "fu1_m", "fu2_m", "fu2_m", "fu3_m"),
                          names_to = "timepoint",
                          values_to = "m")

ts_sd_long <- pivot_longer(ts_sd, 
                           cols = c("pre_sd", "post_sd", "fu1_sd", "fu2_sd", "fu2_sd", "fu3_sd"),
                           names_to = "timepoint",
                           values_to = "sd")

ts_t_long <- pivot_longer(ts_t,
                          cols = c("pre_t", "post_t", "fu1_t", "fu2_t", "fu3_t"),
                          names_to = "timepoint",
                          values_to = "t")

#merge long datasets
ts_sd_long$timepoint <-  gsub("\\_sd*$","",ts_sd_long$timepoint)
ts_t_long$timepoint <- gsub("\\_t*$","",ts_t_long$timepoint)
ts_m_long$timepoint <- gsub("\\_m*$","",ts_m_long$timepoint)

ts_sdt_long <- merge(ts_sd_long, ts_t_long, c("cohort", "timepoint"))
ts_long <- merge(ts_sdt_long, ts_m_long, c("cohort", "timepoint"))

#create max_score column
ts_long$max_scale <- as.numeric(questionnaires$max_scale)[match(as.character(ts_long$instrument_name), as.character(questionnaires$q))]

#create min_score column
ts_long$min_scale <- as.numeric(questionnaires$min_scale)[match(as.character(ts_long$instrument_name), as.character(questionnaires$q))]

#create reverse scoring variable
ts_long$rev_score <- questionnaires$reverse_scoring[match(as.character(ts_long$instrument_name), as.character(questionnaires$q))]

#reverse scoring
ts_long$rev_score_m <- (ts_long$max_scale)-ts_long$m 

#combining rev_score and normal score on contion of ts_long$rev_score

ts_long$m_final <- ts_long$m

for (row in 1:nrow(ts_long)) {
  if (ts_long[row, "rev_score"] == 1 & !is.na(ts_long[row, "rev_score"])) {
    # replace value by ts_long$rev_score_m
    ts_long[row, "m_final"] <- ts_long[row, "rev_score_m"]
  }
}

#standardize mean
ts_long$m_stand = ((ts_long$m_final-ts_long$min_scale)/(ts_long$max_scale-ts_long$min_scale))*100

#create plot
p <- ggplot(ts_long, aes(x=t, y=m_stand, group=cohort, color=cohort, text = 
                           paste("Author: ", author,
                                 "<br>Year: ", year,
                                 "<br>Cohort ID: ", cohort_id,
                                 "<br>Instrument: ", instrument_name,
                                 "<br>Raw mean: ", m,
                                 "<br>Raw SD: ", sd,
                                 "<br>Standardized score ", m_stand
                           ))) +
  labs(y= "outcome standardized (0-100)") +
  geom_line(data=ts_long[!is.na(ts_long$m_stand),]) + 
  geom_point() +
  scale_x_continuous(name = "Time (months)",
                     breaks = c(-5, 0, 3, 6, 12, 24, 60, 120),
                     labels = c("pre", "post", "3m", "6m", "12m", "24m", "60m", "120m"),
                     limits = c(-5, 200))

ggplotly(p, tooltip = "text") %>%
  layout(
    xaxis = list(
      tickvals = c(-5, 0, 3, 6, 12, 24, 60, 120),
      ticktext = c("pre", "post", "3m", "6m", "12m", "24m", "60m", "120m"),
      ticklen = 5,
      tickwidth = 2,
      tickcolor = toRGB("blue"),
      breaks = c(-7, 26),
      range=c(-7, 26)
    ),
    yaxis = list(
      range=c(0, 100))
  ) 
```

### Pain intensity

```{r time series: pain intensity}
#subset dataset with measurements on pain_interference

dat_pintens <- dat_clean %>%
    filter(measurements_pain_intensity == "yes")  

#create dataframe for mean values over time    
  ts_m <- select (dat_pintens, cohort, author, year, cohort_id, pintens_pre_m, pintens_post_m, pintens_fu1_m,
                  pintens_fu2_m, pintens_fu3_m, measurements_pain_intensity, pintens_name_measurement_instrument) %>%
    rename(instrument_name = pintens_name_measurement_instrument, 
           pre_m = pintens_pre_m,
           post_m = pintens_post_m,
           fu1_m = pintens_fu1_m,
           fu2_m = pintens_fu2_m,
           fu3_m = pintens_fu3_m,
           instrument_present = measurements_pain_intensity)
  
  #create dataframe for SD values over time and change columns to numeric  
    ts_sd <- select (dat_pintens, cohort, pintens_pre_sd, pintens_post_sd, pintens_fu1_sd,
                   pintens_fu2_sd, pintens_fu3_sd) %>%
    rename( pre_sd = pintens_pre_sd,
            post_sd = pintens_post_sd,
            fu1_sd = pintens_fu1_sd,
            fu2_sd = pintens_fu2_sd,
            fu3_sd = pintens_fu3_sd)
  
    cols.num <- c("pre_sd","post_sd", "fu1_sd", "fu2_sd", "fu3_sd")
    ts_sd[cols.num] <- sapply(ts_sd[cols.num],as.numeric)
    
#create dataframe for time and add pre/post values   
     ts_t <- select (dat_pintens, cohort, pintens_fu1_t, pintens_fu2_t, pintens_fu3_t) %>%
    rename( fu1_t = pintens_fu1_t,
            fu2_t = pintens_fu2_t,
            fu3_t = pintens_fu3_t)

ts_t$pre_t = -5
ts_t$post_t = 0

#convert to long dataset
# The arguments to gather():
# - data: Data object
# - key: Name of new key column (made from names of data columns)
# - value: Name of new value column
# - ...: Names of source columns that contain values
# - factor_key: Treat the new key column as a factor (instead of character vector)
ts_m_long <- pivot_longer(ts_m, 
                          cols = c("pre_m", "post_m", "fu1_m", "fu2_m", "fu2_m", "fu3_m"),
                          names_to = "timepoint",
                          values_to = "m")

ts_sd_long <- pivot_longer(ts_sd, 
                           cols = c("pre_sd", "post_sd", "fu1_sd", "fu2_sd", "fu2_sd", "fu3_sd"),
                           names_to = "timepoint",
                           values_to = "sd")

ts_t_long <- pivot_longer(ts_t,
                          cols = c("pre_t", "post_t", "fu1_t", "fu2_t", "fu3_t"),
                          names_to = "timepoint",
                          values_to = "t")

#merge long datasets
ts_sd_long$timepoint <-  gsub("\\_sd*$","",ts_sd_long$timepoint)
ts_t_long$timepoint <- gsub("\\_t*$","",ts_t_long$timepoint)
ts_m_long$timepoint <- gsub("\\_m*$","",ts_m_long$timepoint)

ts_sdt_long <- merge(ts_sd_long, ts_t_long, c("cohort", "timepoint"))
ts_long <- merge(ts_sdt_long, ts_m_long, c("cohort", "timepoint"))

#create max_score column
ts_long$max_scale <- as.numeric(questionnaires$max_scale)[match(as.character(ts_long$instrument_name), as.character(questionnaires$q))]

#create min_score column
ts_long$min_scale <- as.numeric(questionnaires$min_scale)[match(as.character(ts_long$instrument_name), as.character(questionnaires$q))]

#create reverse scoring variable
ts_long$rev_score <- questionnaires$reverse_scoring[match(as.character(ts_long$instrument_name), as.character(questionnaires$q))]

#reverse scoring and standardizing, using the following principle: distance between the mean score and the unfavorable end of the scale divided by the total scale distance, multiplied by 100.
ts_long$m_rev_stand <- (ts_long$max_scale-ts_long$m)/(ts_long$max_scale-ts_long$min_scale)*100

#standardize mean for data that does not have to be reversed
ts_long$m_stand = ((ts_long$m-ts_long$min_scale)/(ts_long$max_scale-ts_long$min_scale))*100

#combining rev_score and normal score on contion of ts_long$rev_score

ts_long$m_final <- ts_long$m_stand

for (row in 1:nrow(ts_long)) {
  if (ts_long[row, "rev_score"] == 1 & !is.na(ts_long[row, "rev_score"])) {
    # replace value by ts_long$rev_score_m
    ts_long[row, "m_final"] <- ts_long[row, "m_rev_stand"]
  }
}

#create plot
p <- ggplot(ts_long, aes(x=t, y=m_final, group=cohort, color=cohort, text = 
                           paste("Author: ", author,
                                 "<br>Year: ", year,
                                 "<br>Cohort ID: ", cohort_id,
                                 "<br>Instrument: ", instrument_name,
                                 "<br>Raw mean: ", m,
                                 "<br>Raw SD: ", sd,
                                 "<br>Standardized score ", m_final
                           ))) +
  labs(y= "outcome standardized (0-100)") +
  geom_line(data=ts_long[!is.na(ts_long$m_final),]) + 
  geom_point() +
  scale_x_continuous(name = "Time (months)",
                     breaks = c(-5, 0, 3, 6, 12, 24, 60, 120),
                     labels = c("pre", "post", "3m", "6m", "12m", "24m", "60m", "120m"),
                     limits = c(-5, 200))

ggplotly(p, tooltip = "text") %>%
  layout(
    xaxis = list(
      tickvals = c(-5, 0, 3, 6, 12, 24, 60, 120),
      ticktext = c("pre", "post", "3m", "6m", "12m", "24m", "60m", "120m"),
      ticklen = 5,
      tickwidth = 2,
      tickcolor = toRGB("blue"),
      breaks = c(-7, 26),
      range=c(-7, 26)
    ),
    yaxis = list(
      range=c(0, 100))
  ) 
```

### Physical function

```{r}
#subset dataset with measurements on pain_interference

dat_pf <- dat_clean %>%
    dplyr::filter(measurements_physical_functioning == "yes")
  
#create dataframe for mean values over time 
  ts_m <- select (dat_pf, cohort, author, year, cohort_id, pf_pre_m, pf_post_m, pf_fu1_m,
                  pf_fu2_m, pf_fu3_m, measurements_physical_functioning, pf_measurement_name) %>%
    rename(instrument_name = pf_measurement_name, 
           pre_m = pf_pre_m,
           post_m = pf_post_m,
           fu1_m = pf_fu1_m,
           fu2_m = pf_fu2_m,
           fu3_m = pf_fu3_m,
           instrument_present = measurements_physical_functioning)

#create dataframe for SD values over time and change columns to numeric    
  ts_sd <- select (dat_pf, cohort, pf_pre_sd, pf_post_sd, pf_fu1_sd,
                   pf_fu2_sd, pf_fu3_sd) %>%
    rename( pre_sd = pf_pre_sd,
            post_sd = pf_post_sd,
            fu1_sd = pf_fu1_sd,
            fu2_sd = pf_fu2_sd,
            fu3_sd = pf_fu3_sd)
  
cols.num <- c("pre_sd","post_sd", "fu1_sd", "fu2_sd", "fu3_sd")
ts_sd[cols.num] <- sapply(ts_sd[cols.num],as.numeric)
  
#create dataframe for time and add pre/post values 
ts_t <- select (dat_pf, cohort, pf_fu1_t, pf_fu2_t, pf_fu3_t) %>%
    rename( fu1_t = pf_fu1_t,
            fu2_t = pf_fu2_t,
            fu3_t = pf_fu3_t)

ts_t$pre_t = -5
ts_t$post_t = 0

#convert to long dataset
# The arguments to gather():
# - data: Data object
# - key: Name of new key column (made from names of data columns)
# - value: Name of new value column
# - ...: Names of source columns that contain values
# - factor_key: Treat the new key column as a factor (instead of character vector)
ts_m_long <- pivot_longer(ts_m, 
                          cols = c("pre_m", "post_m", "fu1_m", "fu2_m", "fu2_m", "fu3_m"),
                          names_to = "timepoint",
                          values_to = "m")

ts_sd_long <- pivot_longer(ts_sd, 
                           cols = c("pre_sd", "post_sd", "fu1_sd", "fu2_sd", "fu2_sd", "fu3_sd"),
                           names_to = "timepoint",
                           values_to = "sd")

ts_t_long <- pivot_longer(ts_t,
                          cols = c("pre_t", "post_t", "fu1_t", "fu2_t", "fu3_t"),
                          names_to = "timepoint",
                          values_to = "t")

#merge long datasets
ts_sd_long$timepoint <-  gsub("\\_sd*$","",ts_sd_long$timepoint)
ts_t_long$timepoint <- gsub("\\_t*$","",ts_t_long$timepoint)
ts_m_long$timepoint <- gsub("\\_m*$","",ts_m_long$timepoint)

ts_sdt_long <- merge(ts_sd_long, ts_t_long, c("cohort", "timepoint"))
ts_long <- merge(ts_sdt_long, ts_m_long, c("cohort", "timepoint"))

#create max_score column
ts_long$max_scale <- as.numeric(questionnaires$max_scale)[match(as.character(ts_long$instrument_name), as.character(questionnaires$q))]

#create min_score column
ts_long$min_scale <- as.numeric(questionnaires$min_scale)[match(as.character(ts_long$instrument_name), as.character(questionnaires$q))]

#create reverse scoring variable
ts_long$rev_score <- questionnaires$reverse_scoring[match(as.character(ts_long$instrument_name), as.character(questionnaires$q))]

#reverse scoring and standardizing, using the following principle: distance between the mean score and the unfavorable end of the scale divided by the total scale distance, multiplied by 100.
ts_long$m_rev_stand <- (ts_long$max_scale-ts_long$m)/(ts_long$max_scale-ts_long$min_scale)*100

#standardize mean for data that does not have to be reversed
ts_long$m_stand = ((ts_long$m-ts_long$min_scale)/(ts_long$max_scale-ts_long$min_scale))*100

#combining rev_score and normal score on contion of ts_long$rev_score

ts_long$m_final <- ts_long$m_stand

for (row in 1:nrow(ts_long)) {
  if (ts_long[row, "rev_score"] == 1 & !is.na(ts_long[row, "rev_score"])) {
    # replace value by ts_long$rev_score_m
    ts_long[row, "m_final"] <- ts_long[row, "m_rev_stand"]
  }
}

#create plot
p <- ggplot(ts_long, aes(x=t, y=m_final, group=cohort, color=cohort, text = 
                           paste("Author: ", author,
                                 "<br>Year: ", year,
                                 "<br>Cohort ID: ", cohort_id,
                                 "<br>Instrument: ", instrument_name,
                                 "<br>Raw mean: ", m,
                                 "<br>Raw SD: ", sd,
                                 "<br>Standardized score ", m_final
                           ))) +
  labs(y= "outcome standardized (0-100)") +
  geom_line(data=ts_long[!is.na(ts_long$m_final),]) + 
  geom_point() +
  scale_x_continuous(name = "Time (months)",
                     breaks = c(-5, 0, 3, 6, 12, 24, 60, 120),
                     labels = c("pre", "post", "3m", "6m", "12m", "24m", "60m", "120m"),
                     limits = c(-5, 200))

ggplotly(p, tooltip = "text") %>%
  layout(
    xaxis = list(
      tickvals = c(-5, 0, 3, 6, 12, 24, 60, 120),
      ticktext = c("pre", "post", "3m", "6m", "12m", "24m", "60m", "120m"),
      ticklen = 5,
      tickwidth = 2,
      tickcolor = toRGB("blue"),
      breaks = c(-7, 26),
      range=c(-7, 26)
    ),
    yaxis = list(
      range=c(0, 100))
  ) 
```

### Depression

```{r}
#subset dataset with measurements on depression

dat_dep <- dat_clean %>%
  dplyr::filter(measurements_depression == "yes")  

#create dataframe for mean values over time    
ts_m <- select (dat_dep, cohort, author, year, cohort_id, dep_pre_m, dep_post_m, dep_fu1_m,
                dep_fu2_m, dep_fu3_m, measurements_depression, dep_name_measurement_instrument) %>%
  rename(instrument_name = dep_name_measurement_instrument, 
         pre_m = dep_pre_m,
         post_m = dep_post_m,
         fu1_m = dep_fu1_m,
         fu2_m = dep_fu2_m,
         fu3_m = dep_fu3_m,
         instrument_present = measurements_depression)
 
#create dataframe for SD values over time and change columns to numeric   
ts_sd <- select (dat_dep, cohort, dep_pre_sd, dep_post_sd, dep_fu1_sd,
                 dep_fu2_sd, dep_fu3_sd) %>%
  rename( pre_sd = dep_pre_sd,
          post_sd = dep_post_sd,
          fu1_sd = dep_fu1_sd,
          fu2_sd = dep_fu2_sd,
          fu3_sd = dep_fu3_sd)

cols.num <- c("pre_sd","post_sd", "fu1_sd", "fu2_sd", "fu3_sd")
ts_sd[cols.num] <- sapply(ts_sd[cols.num],as.numeric)

#create dataframe for time and add pre/post values  
ts_t <- select (dat_dep, cohort, dep_fu1_t, dep_fu2_t, dep_fu3_t) %>%
  rename( fu1_t = dep_fu1_t,
          fu2_t = dep_fu2_t,
          fu3_t = dep_fu3_t)

ts_t$pre_t = -5
ts_t$post_t = 0

#convert to long dataset
# The arguments to gather():
# - data: Data object
# - key: Name of new key column (made from names of data columns)
# - value: Name of new value column
# - ...: Names of source columns that contain values
# - factor_key: Treat the new key column as a factor (instead of character vector)
ts_m_long <- pivot_longer(ts_m, 
                          cols = c("pre_m", "post_m", "fu1_m", "fu2_m", "fu2_m", "fu3_m"),
                          names_to = "timepoint",
                          values_to = "m")

ts_sd_long <- pivot_longer(ts_sd, 
                           cols = c("pre_sd", "post_sd", "fu1_sd", "fu2_sd", "fu2_sd", "fu3_sd"),
                           names_to = "timepoint",
                           values_to = "sd")

ts_t_long <- pivot_longer(ts_t,
                          cols = c("pre_t", "post_t", "fu1_t", "fu2_t", "fu3_t"),
                          names_to = "timepoint",
                          values_to = "t")

#merge long datasets
ts_sd_long$timepoint <-  gsub("\\_sd*$","",ts_sd_long$timepoint)
ts_t_long$timepoint <- gsub("\\_t*$","",ts_t_long$timepoint)
ts_m_long$timepoint <- gsub("\\_m*$","",ts_m_long$timepoint)

ts_sdt_long <- merge(ts_sd_long, ts_t_long, c("cohort", "timepoint"))
ts_long <- merge(ts_sdt_long, ts_m_long, c("cohort", "timepoint"))

#create max_score column
ts_long$max_scale <- as.numeric(questionnaires$max_scale)[match(as.character(ts_long$instrument_name), as.character(questionnaires$q))]

#create min_score column
ts_long$min_scale <- as.numeric(questionnaires$min_scale)[match(as.character(ts_long$instrument_name), as.character(questionnaires$q))]

#create reverse scoring variable
ts_long$rev_score <- questionnaires$reverse_scoring[match(as.character(ts_long$instrument_name), as.character(questionnaires$q))]

#reverse scoring and standardizing, using the following principle: distance between the mean score and the unfavorable end of the scale divided by the total scale distance, multiplied by 100.
ts_long$m_rev_stand <- (ts_long$max_scale-ts_long$m)/(ts_long$max_scale-ts_long$min_scale)*100

#standardize mean for data that does not have to be reversed
ts_long$m_stand = ((ts_long$m-ts_long$min_scale)/(ts_long$max_scale-ts_long$min_scale))*100

#combining rev_score and normal score on contion of ts_long$rev_score

ts_long$m_final <- ts_long$m_stand

for (row in 1:nrow(ts_long)) {
  if (ts_long[row, "rev_score"] == 1 & !is.na(ts_long[row, "rev_score"])) {
    # replace value by ts_long$rev_score_m
    ts_long[row, "m_final"] <- ts_long[row, "m_rev_stand"]
  }
}

#create plot
p <- ggplot(ts_long, aes(x=t, y=m_final, group=cohort, color=cohort, text = 
                           paste("Author: ", author,
                                 "<br>Year: ", year,
                                 "<br>Cohort ID: ", cohort_id,
                                 "<br>Instrument: ", instrument_name,
                                 "<br>Raw mean: ", m,
                                 "<br>Raw SD: ", sd,
                                 "<br>Standardized score ", m_final
                           ))) +
  labs(y= "outcome standardized (0-100)") +
  geom_line(data=ts_long[!is.na(ts_long$m_final),]) + 
  geom_point() +
  scale_x_continuous(name = "Time (months)",
                     breaks = c(-5, 0, 3, 6, 12, 24, 60, 120),
                     labels = c("pre", "post", "3m", "6m", "12m", "24m", "60m", "120m"),
                     limits = c(-5, 200))

ggplotly(p, tooltip = "text") %>%
  layout(
    xaxis = list(
      tickvals = c(-5, 0, 3, 6, 12, 24, 60, 120),
      ticktext = c("pre", "post", "3m", "6m", "12m", "24m", "60m", "120m"),
      ticklen = 5,
      tickwidth = 2,
      tickcolor = toRGB("blue"),
      breaks = c(-7, 26),
      range=c(-7, 26)
    ),
    yaxis = list(
      range=c(0, 100))
  ) 

```

### Anxiety

```{r}
#subset dataset with measurements on anxiety

dat_anx <- dat_clean %>%
    dplyr::filter(measurements_anxiety == "yes")  

#create dataframe for mean values over time   
  ts_m <- select (dat_anx, cohort, author, year, cohort_id, anx_pre_m, anx_post_m, anx_fu1_m,
                  anx_fu2_m, anx_fu3_m, measurements_anxiety, anx_name_measurement_instrument) %>%
    rename(instrument_name = anx_name_measurement_instrument, 
           pre_m = anx_pre_m,
           post_m = anx_post_m,
           fu1_m = anx_fu1_m,
           fu2_m = anx_fu2_m,
           fu3_m = anx_fu3_m,
           instrument_present = measurements_anxiety)
 
#create dataframe for SD values over time and change columns to numeric  
  ts_sd <- select (dat_anx, cohort, anx_pre_sd, anx_post_sd, anx_fu1_sd,
                   anx_fu2_sd, anx_fu3_sd) %>%
    rename( pre_sd = anx_pre_sd,
            post_sd = anx_post_sd,
            fu1_sd = anx_fu1_sd,
            fu2_sd = anx_fu2_sd,
            fu3_sd = anx_fu3_sd)
  
  cols.num <- c("pre_sd","post_sd", "fu1_sd", "fu2_sd", "fu3_sd")
  ts_sd[cols.num] <- sapply(ts_sd[cols.num],as.numeric)
  
  #create dataframe for time and add pre/post values
   ts_t <- select (dat_anx, cohort, anx_fu1_t, anx_fu2_t, anx_fu3_t) %>%
    rename( fu1_t = anx_fu1_t,
            fu2_t = anx_fu2_t,
            fu3_t = anx_fu3_t)

ts_t$pre_t = -5
ts_t$post_t = 0

#change SD columns to numeric
cols.num <- c("pre_sd","post_sd", "fu1_sd", "fu2_sd", "fu3_sd")
ts_sd[cols.num] <- sapply(ts_sd[cols.num],as.numeric)
#sapply(ts_sd, class)


#convert to long dataset
# The arguments to gather():
# - data: Data object
# - key: Name of new key column (made from names of data columns)
# - value: Name of new value column
# - ...: Names of source columns that contain values
# - factor_key: Treat the new key column as a factor (instead of character vector)
ts_m_long <- pivot_longer(ts_m, 
                          cols = c("pre_m", "post_m", "fu1_m", "fu2_m", "fu2_m", "fu3_m"),
                          names_to = "timepoint",
                          values_to = "m")

ts_sd_long <- pivot_longer(ts_sd, 
                           cols = c("pre_sd", "post_sd", "fu1_sd", "fu2_sd", "fu2_sd", "fu3_sd"),
                           names_to = "timepoint",
                           values_to = "sd")

ts_t_long <- pivot_longer(ts_t,
                          cols = c("pre_t", "post_t", "fu1_t", "fu2_t", "fu3_t"),
                          names_to = "timepoint",
                          values_to = "t")

#merge long datasets
ts_sd_long$timepoint <-  gsub("\\_sd*$","",ts_sd_long$timepoint)
ts_t_long$timepoint <- gsub("\\_t*$","",ts_t_long$timepoint)
ts_m_long$timepoint <- gsub("\\_m*$","",ts_m_long$timepoint)

ts_sdt_long <- merge(ts_sd_long, ts_t_long, c("cohort", "timepoint"))
ts_long <- merge(ts_sdt_long, ts_m_long, c("cohort", "timepoint"))

#create max_score column
ts_long$max_scale <- as.numeric(questionnaires$max_scale)[match(as.character(ts_long$instrument_name), as.character(questionnaires$q))]

#create min_score column
ts_long$min_scale <- as.numeric(questionnaires$min_scale)[match(as.character(ts_long$instrument_name), as.character(questionnaires$q))]

#create reverse scoring variable
ts_long$rev_score <- questionnaires$reverse_scoring[match(as.character(ts_long$instrument_name), as.character(questionnaires$q))]

#reverse scoring and standardizing, using the following principle: distance between the mean score and the unfavorable end of the scale divided by the total scale distance, multiplied by 100.
ts_long$m_rev_stand <- (ts_long$max_scale-ts_long$m)/(ts_long$max_scale-ts_long$min_scale)*100

#standardize mean for data that does not have to be reversed
ts_long$m_stand = ((ts_long$m-ts_long$min_scale)/(ts_long$max_scale-ts_long$min_scale))*100

#combining rev_score and normal score on contion of ts_long$rev_score

ts_long$m_final <- ts_long$m_stand

for (row in 1:nrow(ts_long)) {
  if (ts_long[row, "rev_score"] == 1 & !is.na(ts_long[row, "rev_score"])) {
    # replace value by ts_long$rev_score_m
    ts_long[row, "m_final"] <- ts_long[row, "m_rev_stand"]
  }
}

#create plot
p <- ggplot(ts_long, aes(x=t, y=m_final, group=cohort, color=cohort, text = 
                           paste("Author: ", author,
                                 "<br>Year: ", year,
                                 "<br>Cohort ID: ", cohort_id,
                                 "<br>Instrument: ", instrument_name,
                                 "<br>Raw mean: ", m,
                                 "<br>Raw SD: ", sd,
                                 "<br>Standardized score ", m_final
                           ))) +
  labs(y= "outcome standardized (0-100)") +
  geom_line(data=ts_long[!is.na(ts_long$m_final),]) + 
  geom_point() +
  scale_x_continuous(name = "Time (months)",
                     breaks = c(-5, 0, 3, 6, 12, 24, 60, 120),
                     labels = c("pre", "post", "3m", "6m", "12m", "24m", "60m", "120m"),
                     limits = c(-5, 200))

ggplotly(p, tooltip = "text") %>%
  layout(
    xaxis = list(
      tickvals = c(-5, 0, 3, 6, 12, 24, 60, 120),
      ticktext = c("pre", "post", "3m", "6m", "12m", "24m", "60m", "120m"),
      ticklen = 5,
      tickwidth = 2,
      tickcolor = toRGB("blue"),
      breaks = c(-7, 26),
      range=c(-7, 26)
    ),
    yaxis = list(
      range=c(0, 100))
  ) 
```

### General emotional functioning

```{r}
#subset dataset with measurements on pain_interference

dat_ef <- dat_clean %>%
    dplyr::filter(measurements_general_emotional_functioning == "yes")  

#create dataframe for mean values over time    
  ts_m <- select (dat_ef, cohort, author, year, cohort_id, ef_pre_m, ef_post_m, ef_fu1_m,
                  ef_fu2_m, ef_fu3_m, measurements_general_emotional_functioning, ef_name_measurement_instrument) %>%
    rename(instrument_name = ef_name_measurement_instrument, 
           pre_m = ef_pre_m,
           post_m = ef_post_m,
           fu1_m = ef_fu1_m,
           fu2_m = ef_fu2_m,
           fu3_m = ef_fu3_m,
           instrument_present = measurements_general_emotional_functioning)

  #create dataframe for SD values over time and change columns to numeric    
  ts_sd <- select (dat_ef, cohort, ef_pre_sd, ef_post_sd, ef_fu1_sd,
                   ef_fu2_sd, ef_fu3_sd) %>%
    rename( pre_sd = ef_pre_sd,
            post_sd = ef_post_sd,
            fu1_sd = ef_fu1_sd,
            fu2_sd = ef_fu2_sd,
            fu3_sd = ef_fu3_sd)
 
  cols.num <- c("pre_sd","post_sd", "fu1_sd", "fu2_sd", "fu3_sd")
  ts_sd[cols.num] <- sapply(ts_sd[cols.num],as.numeric)
  
  #create dataframe for time and add pre/post values  
  ts_t <- select (dat_ef, cohort, ef_fu1_t, ef_fu2_t, ef_fu3_t) %>%
    rename( fu1_t = ef_fu1_t,
            fu2_t = ef_fu2_t,
            fu3_t = ef_fu3_t)
  
ts_t$pre_t = -5
ts_t$post_t = 0

#convert to long dataset
# The arguments to gather():
# - data: Data object
# - key: Name of new key column (made from names of data columns)
# - value: Name of new value column
# - ...: Names of source columns that contain values
# - factor_key: Treat the new key column as a factor (instead of character vector)
ts_m_long <- pivot_longer(ts_m, 
                          cols = c("pre_m", "post_m", "fu1_m", "fu2_m", "fu2_m", "fu3_m"),
                          names_to = "timepoint",
                          values_to = "m")

ts_sd_long <- pivot_longer(ts_sd, 
                           cols = c("pre_sd", "post_sd", "fu1_sd", "fu2_sd", "fu2_sd", "fu3_sd"),
                           names_to = "timepoint",
                           values_to = "sd")

ts_t_long <- pivot_longer(ts_t,
                          cols = c("pre_t", "post_t", "fu1_t", "fu2_t", "fu3_t"),
                          names_to = "timepoint",
                          values_to = "t")

#merge long datasets
ts_sd_long$timepoint <-  gsub("\\_sd*$","",ts_sd_long$timepoint)
ts_t_long$timepoint <- gsub("\\_t*$","",ts_t_long$timepoint)
ts_m_long$timepoint <- gsub("\\_m*$","",ts_m_long$timepoint)

ts_sdt_long <- merge(ts_sd_long, ts_t_long, c("cohort", "timepoint"))
ts_long <- merge(ts_sdt_long, ts_m_long, c("cohort", "timepoint"))

#create max_score column
ts_long$max_scale <- as.numeric(questionnaires$max_scale)[match(as.character(ts_long$instrument_name), as.character(questionnaires$q))]

#create min_score column
ts_long$min_scale <- as.numeric(questionnaires$min_scale)[match(as.character(ts_long$instrument_name), as.character(questionnaires$q))]

#create reverse scoring variable
ts_long$rev_score <- questionnaires$reverse_scoring[match(as.character(ts_long$instrument_name), as.character(questionnaires$q))]

#reverse scoring and standardizing, using the following principle: distance between the mean score and the unfavorable end of the scale divided by the total scale distance, multiplied by 100.
ts_long$m_rev_stand <- (ts_long$max_scale-ts_long$m)/(ts_long$max_scale-ts_long$min_scale)*100

#standardize mean for data that does not have to be reversed
ts_long$m_stand = ((ts_long$m-ts_long$min_scale)/(ts_long$max_scale-ts_long$min_scale))*100

#combining rev_score and normal score on contion of ts_long$rev_score

ts_long$m_final <- ts_long$m_stand

for (row in 1:nrow(ts_long)) {
  if (ts_long[row, "rev_score"] == 1 & !is.na(ts_long[row, "rev_score"])) {
    # replace value by ts_long$rev_score_m
    ts_long[row, "m_final"] <- ts_long[row, "m_rev_stand"]
  }
}

#create plot
p <- ggplot(ts_long, aes(x=t, y=m_final, group=cohort, color=cohort, text = 
                           paste("Author: ", author,
                                 "<br>Year: ", year,
                                 "<br>Cohort ID: ", cohort_id,
                                 "<br>Instrument: ", instrument_name,
                                 "<br>Raw mean: ", m,
                                 "<br>Raw SD: ", sd,
                                 "<br>Standardized score ", m_final
                           ))) +
  labs(y= "outcome standardized (0-100)") +
  geom_line(data=ts_long[!is.na(ts_long$m_final),]) + 
  geom_point() +
  scale_x_continuous(name = "Time (months)",
                     breaks = c(-5, 0, 3, 6, 12, 24, 60, 120),
                     labels = c("pre", "post", "3m", "6m", "12m", "24m", "60m", "120m"),
                     limits = c(-5, 200))

ggplotly(p, tooltip = "text") %>%
  layout(
    xaxis = list(
      tickvals = c(-5, 0, 3, 6, 12, 24, 60, 120),
      ticktext = c("pre", "post", "3m", "6m", "12m", "24m", "60m", "120m"),
      ticklen = 5,
      tickwidth = 2,
      tickcolor = toRGB("blue"),
      breaks = c(-7, 26),
      range=c(-7, 26)
    ),
    yaxis = list(
      range=c(0, 100))
  ) 
```

### Anger

```{r}
#subset dataset with measurements on pain_interference

dat_ang <- dat_clean %>%
    dplyr::filter(measurements_anger == "yes")  

#create dataframe for mean values over time    
  ts_m <- select (dat_ang, cohort, author, year, cohort_id, ang_pre_m, ang_post_m, ang_fu1_m,
                  ang_fu2_m, ang_fu3_m, measurements_anger, ang_name_measurement_instrument) %>%
    rename(instrument_name = ang_name_measurement_instrument, 
           pre_m = ang_pre_m,
           post_m = ang_post_m,
           fu1_m = ang_fu1_m,
           fu2_m = ang_fu2_m,
           fu3_m = ang_fu3_m,
           instrument_present = measurements_anger)
  
#create dataframe for SD values over time and change columns to numeric   
  ts_sd <- select (dat_ang, cohort, ang_pre_sd, ang_post_sd, ang_fu1_sd,
                   ang_fu2_sd, ang_fu3_sd) %>%
    rename( pre_sd = ang_pre_sd,
            post_sd = ang_post_sd,
            fu1_sd = ang_fu1_sd,
            fu2_sd = ang_fu2_sd,
            fu3_sd = ang_fu3_sd)

#create dataframe for time and add pre/post values 
ts_t <- select (dat_ang, cohort, ang_fu1_t, ang_fu2_t, ang_fu3_t) %>%
    rename( fu1_t = ang_fu1_t,
            fu2_t = ang_fu2_t,
            fu3_t = ang_fu3_t)

ts_t$pre_t = -5
ts_t$post_t = 0

#convert to long dataset
# The arguments to gather():
# - data: Data object
# - key: Name of new key column (made from names of data columns)
# - value: Name of new value column
# - ...: Names of source columns that contain values
# - factor_key: Treat the new key column as a factor (instead of character vector)
ts_m_long <- pivot_longer(ts_m, 
                          cols = c("pre_m", "post_m", "fu1_m", "fu2_m", "fu2_m", "fu3_m"),
                          names_to = "timepoint",
                          values_to = "m")

ts_sd_long <- pivot_longer(ts_sd, 
                           cols = c("pre_sd", "post_sd", "fu1_sd", "fu2_sd", "fu2_sd", "fu3_sd"),
                           names_to = "timepoint",
                           values_to = "sd")

ts_t_long <- pivot_longer(ts_t,
                          cols = c("pre_t", "post_t", "fu1_t", "fu2_t", "fu3_t"),
                          names_to = "timepoint",
                          values_to = "t")

#merge long datasets
ts_sd_long$timepoint <-  gsub("\\_sd*$","",ts_sd_long$timepoint)
ts_t_long$timepoint <- gsub("\\_t*$","",ts_t_long$timepoint)
ts_m_long$timepoint <- gsub("\\_m*$","",ts_m_long$timepoint)

ts_sdt_long <- merge(ts_sd_long, ts_t_long, c("cohort", "timepoint"))
ts_long <- merge(ts_sdt_long, ts_m_long, c("cohort", "timepoint"))

#create max_score column
ts_long$max_scale <- as.numeric(questionnaires$max_scale)[match(as.character(ts_long$instrument_name), as.character(questionnaires$q))]

#create min_score column
ts_long$min_scale <- as.numeric(questionnaires$min_scale)[match(as.character(ts_long$instrument_name), as.character(questionnaires$q))]

#create reverse scoring variable
ts_long$rev_score <- questionnaires$reverse_scoring[match(as.character(ts_long$instrument_name), as.character(questionnaires$q))]

#reverse scoring and standardizing, using the following principle: distance between the mean score and the unfavorable end of the scale divided by the total scale distance, multiplied by 100.
ts_long$m_rev_stand <- (ts_long$max_scale-ts_long$m)/(ts_long$max_scale-ts_long$min_scale)*100

#standardize mean for data that does not have to be reversed
ts_long$m_stand = ((ts_long$m-ts_long$min_scale)/(ts_long$max_scale-ts_long$min_scale))*100

#combining rev_score and normal score on contion of ts_long$rev_score

ts_long$m_final <- ts_long$m_stand

for (row in 1:nrow(ts_long)) {
  if (ts_long[row, "rev_score"] == 1 & !is.na(ts_long[row, "rev_score"])) {
    # replace value by ts_long$rev_score_m
    ts_long[row, "m_final"] <- ts_long[row, "m_rev_stand"]
  }
}

#create plot
p <- ggplot(ts_long, aes(x=t, y=m_final, group=cohort, color=cohort, text = 
                           paste("Author: ", author,
                                 "<br>Year: ", year,
                                 "<br>Cohort ID: ", cohort_id,
                                 "<br>Instrument: ", instrument_name,
                                 "<br>Raw mean: ", m,
                                 "<br>Raw SD: ", sd,
                                 "<br>Standardized score ", m_final
                           ))) +
  labs(y= "outcome standardized (0-100)") +
  geom_line(data=ts_long[!is.na(ts_long$m_final),]) + 
  geom_point() +
  scale_x_continuous(name = "Time (months)",
                     breaks = c(-5, 0, 3, 6, 12, 24, 60, 120),
                     labels = c("pre", "post", "3m", "6m", "12m", "24m", "60m", "120m"),
                     limits = c(-5, 200))

ggplotly(p, tooltip = "text") %>%
  layout(
    xaxis = list(
      tickvals = c(-5, 0, 3, 6, 12, 24, 60, 120),
      ticktext = c("pre", "post", "3m", "6m", "12m", "24m", "60m", "120m"),
      ticklen = 5,
      tickwidth = 2,
      tickcolor = toRGB("blue"),
      breaks = c(-7, 26),
      range=c(-7, 26)
    ),
    yaxis = list(
      range=c(0, 100))
  ) 
```

### Social role functioning

```{r}
#subset dataset with measurements on pain_interference

dat_srf <- dat_clean %>%
    dplyr::filter(measurements_social_role_functioning == "yes")  

#create dataframe for mean values over time    
  ts_m <- select (dat_srf, cohort, author, year, cohort_id, srf_pre_m, srf_post_m, srf_fu1_m,
                  srf_fu2_m, srf_fu3_m, measurements_social_role_functioning, srf_name_measurement_instrument) %>%
    rename(instrument_name = srf_name_measurement_instrument, 
           pre_m = srf_pre_m,
           post_m = srf_post_m,
           fu1_m = srf_fu1_m,
           fu2_m = srf_fu2_m,
           fu3_m = srf_fu3_m
           )

  #create dataframe for SD values over time and change columns to numeric   
  ts_sd <- select (dat_srf, cohort, srf_pre_sd, srf_post_sd, srf_fu1_sd,
                   srf_fu2_sd, srf_fu3_sd) %>%
    rename( pre_sd = srf_pre_sd,
            post_sd = srf_post_sd,
            fu1_sd = srf_fu1_sd,
            fu2_sd = srf_fu2_sd,
            fu3_sd = srf_fu3_sd)

  cols.num <- c("pre_sd","post_sd", "fu1_sd", "fu2_sd", "fu3_sd")
  ts_sd[cols.num] <- sapply(ts_sd[cols.num],as.numeric)
  
#create dataframe for time and add pre/post values   
    ts_t <- select (dat_srf, cohort, srf_fu1_t, srf_fu2_t, srf_fu3_t) %>%
    rename( fu1_t = srf_fu1_t,
            fu2_t = srf_fu2_t,
            fu3_t = srf_fu3_t)

ts_t$pre_t = -5
ts_t$post_t = 0

#convert to long dataset
# The arguments to gather():
# - data: Data object
# - key: Name of new key column (made from names of data columns)
# - value: Name of new value column
# - ...: Names of source columns that contain values
# - factor_key: Treat the new key column as a factor (instead of character vector)
ts_m_long <- pivot_longer(ts_m, 
                          cols = c("pre_m", "post_m", "fu1_m", "fu2_m", "fu2_m", "fu3_m"),
                          names_to = "timepoint",
                          values_to = "m")

ts_sd_long <- pivot_longer(ts_sd, 
                           cols = c("pre_sd", "post_sd", "fu1_sd", "fu2_sd", "fu2_sd", "fu3_sd"),
                           names_to = "timepoint",
                           values_to = "sd")

ts_t_long <- pivot_longer(ts_t,
                          cols = c("pre_t", "post_t", "fu1_t", "fu2_t", "fu3_t"),
                          names_to = "timepoint",
                          values_to = "t")

#merge long datasets
ts_sd_long$timepoint <-  gsub("\\_sd*$","",ts_sd_long$timepoint)
ts_t_long$timepoint <- gsub("\\_t*$","",ts_t_long$timepoint)
ts_m_long$timepoint <- gsub("\\_m*$","",ts_m_long$timepoint)

ts_sdt_long <- merge(ts_sd_long, ts_t_long, c("cohort", "timepoint"))
ts_long <- merge(ts_sdt_long, ts_m_long, c("cohort", "timepoint"))

#create max_score column
ts_long$max_scale <- as.numeric(questionnaires$max_scale)[match(as.character(ts_long$instrument_name), as.character(questionnaires$q))]

#create min_score column
ts_long$min_scale <- as.numeric(questionnaires$min_scale)[match(as.character(ts_long$instrument_name), as.character(questionnaires$q))]

#create reverse scoring variable
ts_long$rev_score <- questionnaires$reverse_scoring[match(as.character(ts_long$instrument_name), as.character(questionnaires$q))]

#reverse scoring and standardizing, using the following principle: distance between the mean score and the unfavorable end of the scale divided by the total scale distance, multiplied by 100.
ts_long$m_rev_stand <- (ts_long$max_scale-ts_long$m)/(ts_long$max_scale-ts_long$min_scale)*100

#standardize mean for data that does not have to be reversed
ts_long$m_stand = ((ts_long$m-ts_long$min_scale)/(ts_long$max_scale-ts_long$min_scale))*100

#combining rev_score and normal score on contion of ts_long$rev_score

ts_long$m_final <- ts_long$m_stand

for (row in 1:nrow(ts_long)) {
  if (ts_long[row, "rev_score"] == 1 & !is.na(ts_long[row, "rev_score"])) {
    # replace value by ts_long$rev_score_m
    ts_long[row, "m_final"] <- ts_long[row, "m_rev_stand"]
  }
}

#create plot
p <- ggplot(ts_long, aes(x=t, y=m_final, group=cohort, color=cohort, text = 
                           paste("Author: ", author,
                                 "<br>Year: ", year,
                                 "<br>Cohort ID: ", cohort_id,
                                 "<br>Instrument: ", instrument_name,
                                 "<br>Raw mean: ", m,
                                 "<br>Raw SD: ", sd,
                                 "<br>Standardized score ", m_final
                           ))) +
  labs(y= "outcome standardized (0-100)") +
  geom_line(data=ts_long[!is.na(ts_long$m_final),]) + 
  geom_point() +
  scale_x_continuous(name = "Time (months)",
                     breaks = c(-5, 0, 3, 6, 12, 24, 60, 120),
                     labels = c("pre", "post", "3m", "6m", "12m", "24m", "60m", "120m"),
                     limits = c(-5, 200))

ggplotly(p, tooltip = "text") %>%
  layout(
    xaxis = list(
      tickvals = c(-5, 0, 3, 6, 12, 24, 60, 120),
      ticktext = c("pre", "post", "3m", "6m", "12m", "24m", "60m", "120m"),
      ticklen = 5,
      tickwidth = 2,
      tickcolor = toRGB("blue"),
      breaks = c(-7, 26),
      range=c(-7, 26)
    ),
    yaxis = list(
      range=c(0, 100))
  ) 
```

### Self-efficacy

```{r}
#subset dataset with measurements on pain_interference

dat_se <- dat_clean %>%
    dplyr::filter(measurements_self_efficacy == "yes")  
  
#create dataframe for mean values over time  
  ts_m <- select (dat_se, cohort, author, year, cohort_id, se_pre_m, se_post_m, se_fu1_m,
                  se_fu2_m, se_fu3_m, measurements_self_efficacy, se_name_measurement_instrument) %>%
    rename(instrument_name = se_name_measurement_instrument, 
           pre_m = se_pre_m,
           post_m = se_post_m,
           fu1_m = se_fu1_m,
           fu2_m = se_fu2_m,
           fu3_m = se_fu3_m,
           instrument_present = measurements_self_efficacy)

#create dataframe for SD values over time and change columns to numeric   
  ts_sd <- select (dat_se, cohort, se_pre_sd, se_post_sd, se_fu1_sd,
                   se_fu2_sd, se_fu3_sd) %>%
    rename( pre_sd = se_pre_sd,
            post_sd = se_post_sd,
            fu1_sd = se_fu1_sd,
            fu2_sd = se_fu2_sd,
            fu3_sd = se_fu3_sd)

cols.num <- c("pre_sd","post_sd", "fu1_sd", "fu2_sd", "fu3_sd")
ts_sd[cols.num] <- sapply(ts_sd[cols.num],as.numeric)
  
#create dataframe for time and add pre/post values   
ts_t <- select (dat_se, cohort, se_fu1_t, se_fu2_t, se_fu3_t) %>%
rename( fu1_t = se_fu1_t,
        fu2_t = se_fu2_t,
        fu3_t = se_fu3_t)

ts_t$pre_t = -5
ts_t$post_t = 0

#convert to long dataset
# The arguments to gather():
# - data: Data object
# - key: Name of new key column (made from names of data columns)
# - value: Name of new value column
# - ...: Names of source columns that contain values
# - factor_key: Treat the new key column as a factor (instead of character vector)
ts_m_long <- pivot_longer(ts_m, 
                          cols = c("pre_m", "post_m", "fu1_m", "fu2_m", "fu2_m", "fu3_m"),
                          names_to = "timepoint",
                          values_to = "m")

ts_sd_long <- pivot_longer(ts_sd, 
                           cols = c("pre_sd", "post_sd", "fu1_sd", "fu2_sd", "fu2_sd", "fu3_sd"),
                           names_to = "timepoint",
                           values_to = "sd")

ts_t_long <- pivot_longer(ts_t,
                          cols = c("pre_t", "post_t", "fu1_t", "fu2_t", "fu3_t"),
                          names_to = "timepoint",
                          values_to = "t")

#merge long datasets
ts_sd_long$timepoint <-  gsub("\\_sd*$","",ts_sd_long$timepoint)
ts_t_long$timepoint <- gsub("\\_t*$","",ts_t_long$timepoint)
ts_m_long$timepoint <- gsub("\\_m*$","",ts_m_long$timepoint)

ts_sdt_long <- merge(ts_sd_long, ts_t_long, c("cohort", "timepoint"))
ts_long <- merge(ts_sdt_long, ts_m_long, c("cohort", "timepoint"))

#create max_score column
ts_long$max_scale <- as.numeric(questionnaires$max_scale)[match(as.character(ts_long$instrument_name), as.character(questionnaires$q))]

#create min_score column
ts_long$min_scale <- as.numeric(questionnaires$min_scale)[match(as.character(ts_long$instrument_name), as.character(questionnaires$q))]

#create reverse scoring variable
ts_long$rev_score <- questionnaires$reverse_scoring[match(as.character(ts_long$instrument_name), as.character(questionnaires$q))]

#reverse scoring and standardizing, using the following principle: distance between the mean score and the unfavorable end of the scale divided by the total scale distance, multiplied by 100.
ts_long$m_rev_stand <- (ts_long$max_scale-ts_long$m)/(ts_long$max_scale-ts_long$min_scale)*100

#standardize mean for data that does not have to be reversed
ts_long$m_stand = ((ts_long$m-ts_long$min_scale)/(ts_long$max_scale-ts_long$min_scale))*100

#combining rev_score and normal score on contion of ts_long$rev_score

ts_long$m_final <- ts_long$m_stand

for (row in 1:nrow(ts_long)) {
  if (ts_long[row, "rev_score"] == 1 & !is.na(ts_long[row, "rev_score"])) {
    # replace value by ts_long$rev_score_m
    ts_long[row, "m_final"] <- ts_long[row, "m_rev_stand"]
  }
}

#create plot
p <- ggplot(ts_long, aes(x=t, y=m_final, group=cohort, color=cohort, text = 
                           paste("Author: ", author,
                                 "<br>Year: ", year,
                                 "<br>Cohort ID: ", cohort_id,
                                 "<br>Instrument: ", instrument_name,
                                 "<br>Raw mean: ", m,
                                 "<br>Raw SD: ", sd,
                                 "<br>Standardized score ", m_final
                           ))) +
  labs(y= "outcome standardized (0-100)") +
  geom_line(data=ts_long[!is.na(ts_long$m_final),]) + 
  geom_point() +
  scale_x_continuous(name = "Time (months)",
                     breaks = c(-5, 0, 3, 6, 12, 24, 60, 120),
                     labels = c("pre", "post", "3m", "6m", "12m", "24m", "60m", "120m"),
                     limits = c(-5, 200))

ggplotly(p, tooltip = "text") %>%
  layout(
    xaxis = list(
      tickvals = c(-5, 0, 3, 6, 12, 24, 60, 120),
      ticktext = c("pre", "post", "3m", "6m", "12m", "24m", "60m", "120m"),
      ticklen = 5,
      tickwidth = 2,
      tickcolor = toRGB("blue"),
      breaks = c(-7, 26),
      range=c(-7, 26)
    ),
    yaxis = list(
      range=c(0, 100))
  ) 
```

Row {data-height=100}
-------------------------------------
Interactive timeseries with scores on a standardized scale that represents the scoring percentage on each respective measurement instrument. Standardization was applied using the following formula: [distance between value and unfavorable end of the scale]/[total distance of the scale]*100. <br />

We also applied reverse scoring to ensure that higher scores indicate improved functioning or wellbeing. <br />


<br /> **Instructions for use:** <br />
1. Each outcome is displayed under a different tab. <br />
2. hovering over a timepoint will reveal the raw scores, standard deviation, cohort information and used measurement instrument. <br />
3. You can navigate the mouse to the upper right corner of the plot to zoom, autoscale, select or print the graph. <br />
4. It is possible to select or deselect each cohort, by clicking on the line in the table legend. If you double click on the line, you can   
   isolate that particular cohort.

Forest Plots {data-orientation=rows}
=======================================================================

Row {.sidebar}
-----------------------------------------------------------------------

```{r}
sliderInput(inputId = "r_value",
                label = "R Correction Value:",
                min = 0,
                max = 1,
                step = 0.1,
                value = .5)

selectInput(inputId = "outcome",
                label = "select ouctome:",
                choices = c("health related quality of life", "physical function", "pain interference", "depression", "anxiety",   
                            "self-efficacy", "social functioning", "pain intensity", "anger", "general emotional functioning"),
                selected = "pain interference")
        
selectInput(inputId = "contrast",
                label = "select contrast:",
                choices = c("pre-post", "post-fu", "pre-fu"),
                selected = "pre-post")
```


Row {data-height=1000}
-------------------------------------

### Shiny forest plots

```{r}
## create shinyapp ##
renderPlot({
    
    data_fp$ri <- input$r_value
    data_fp_meta <- escalc(measure="SMCR", m1i=right_m, m2i=left_m, sd1i=left_sd, ni=right_n, ri=ri, data=data_fp)
    fp_meta <- metafor::summary.escalc(data_fp_meta)
    fp_meta2 <- filter(fp_meta, contrast == input$contrast & outcome == input$outcome)
    fp_meta2$tabletext <- cbind(fp_meta2$author, fp_meta2$year, fp_meta2$right_n, fp_meta2$name_measurement_instrument, 
                                fp_meta2$fu_month)
    
    forestplot(fp_meta2$tabletext, fp_meta2$yi, fp_meta2$ci.lb, fp_meta2$ci.ub,
               xlab = "<---favors pre---     ---favors post--->",
               txt_gp=fpTxtGp(label=gpar(cex=1),
                              ticks=gpar(cex=.6),
                              xlab=gpar(cex = 1),
                              title=gpar(cex = 1.1)),
               col=fpColors(box="black", lines="black", zero = "gray50"),
               zero=0, cex=0.5, lineheight = unit(1, "cm"), boxsize=0.3,
               lwd.ci=2, ci.vertices=TRUE, ci.vertices.height = .1, grid=TRUE,
               align = "l",
               graph.pos = "right",
               clip = c(-4, 4),
               alim = c(-4,4)
    ) 
  })

```

Risk of Bias forms {data-orientation=rows}
=======================================================================

Row {data-height=1200}
-------------------------------------

### Risk of Bias

```{r}
#create table
t_rob2 <- select(dat_rob, `study id`, author, year, 6:17)

reactable(t_rob2,
          defaultSorted = "author",
          defaultSortOrder = "asc",
          defaultColGroup = colGroup(headerClass = "header"),
          style = list(fontFamily = "Arial Narrow", fontSize = "14px"),
          defaultColDef = colDef(
            header = function(value) gsub("_", " ", value, fixed = TRUE),
            cell = function(value) format(value, nsmall = 0),
            align = "left",
            minWidth = 70,
            headerStyle = list(background = "#f7f7f8")
          ),
          columns = list(
            `study id` = colDef(minWidth = 50),
            author = colDef(minWidth = 80),
            year = colDef(minWidth = 50)
          ),
          bordered = FALSE,
          highlight = FALSE,
          striped = FALSE,
          searchable = TRUE,
          showPageSizeOptions = TRUE,
          onClick = "expand"
)
```


Data extraction forms {data-orientation=columns}
=======================================================================


row {.sidebar}
-----------------------------------------------------------------------

```{r}
selectInput(inputId = "author",
                  label = "select author:",
                  choices = author_list,
                  selected = NULL)
```

row
-------------------------------------

```{r}
renderFormattable({
    extraction_data <- as.data.frame(t(dplyr::filter(dat_clean, author == input$author)))
    formattable(extraction_data)  
})
```

Fulltext assessment {data-orientation=rows}
=======================================================================

Row {data-height=1200}
-------------------------------------

### Fulltext assessment

```{r}
reactable(t_fulltext,
          style = list(fontFamily = "Arial Narrow", fontSize = "14px"),
          defaultSorted = "author",
          defaultSortOrder = "asc",
          columns = list(
            author = colDef(minWidth = 105),
            year = colDef(maxWidth = 70),
            'study id' = colDef(maxWidth = 70),
            decision = colDef(maxWidth = 70, cell = function(value) {
              # Render as ✘ or ✓
              if (value == 0) "\u2718" else "\u2713"
            }, style = function(value){
              if (value == 0) {color <- '#B62A3D'} else {color <- '#456355'}
              list(background = color)})
          ),
          bordered = FALSE,
          highlight = FALSE,
          striped = FALSE,
          searchable = TRUE,
          showPageSizeOptions = TRUE,
          ) 
```


